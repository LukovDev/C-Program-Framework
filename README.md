# C Program Framework
### Простой фреймворк для разработки своих проектов на языке программирования C/C++
### Описание:
Это инфраструктурный фреймворк для унификации процесса разработки на языке C/C++/Asm, обеспечивающий единую структуру проекта и кроссплатформенную систему сборки.

Подходит для быстрого старта разработки на C/C++ без использования CMake, Make, Ninja и других сложных систем. Для работы нужен только компилятор C/C++ (gcc/g++) и Python (3.x до 3.11.8 проверено). Систему сборки можно модифицировать или заменить на другую.

#

### Краткая инструкция по использованию:

##### **<| В ЭТОЙ ИНСТРУКЦИИ НЕ БУДЕТ ПРИМЕРОВ НАГЛЯДНО. ВЫ ДОЛЖНЫ САМИ ПОНИМАТЬ ЧТО ДЕЛАЕТЕ |>**

#### 1. Хорошо, а как скачать этот ваш фреймворк?

Для скачивания фреймворка используйте прямую ссылку на скачивание [этого репозитория](https://github.com/LukovDev/C-Program-Framework/archive/refs/heads/master.zip)</br>
Если вы достаточно опытны, вы можете сами модифицировать фреймворк. Например: удалять прочие файлы, по типу ```README.md```, ```LICENSE.txt``` и пр., или модифицировать систему сборки.

На данный момент, последняя версия фреймворка работает на таких системах как (проверено):</br>
- **Windows** [✓]
- **MacOS** [✓]
- **Linux** [✓]

#### 2. Хорошо, вот я скачал, и что дальше?

А дальше, разархивируйте архив и переместите из полученной папки содержимое (все файлы и папки) в другую папку, или переименуйте её так как вам удобнее. Обычно, это название вашего проекта.

#### 3. А потом что?

Теперь, откройте эту папку как папку проекта в редакторе кода.
Все исходные скрипты и коды должны находиться в папке ```src```! (хотя система сборки жёстко не запрещает размещать где-то).

#

### Структура фреймворка

#### 1. Файлы и папки
Перед вами будет примерно такое содержимое:</br>
- MyProject/</br>
  | File/Folder | Description |
  | --- | --- |
  | .vscode/ | Хранит конфигурацию для запуска сборки и запуска бинарника. Требуется python. Если вы не используете редактор **VSCode** то можете удалить. |
  | build/ | Папка в которой находится конфигурация сборки и вывод сборки. |
  | data/ | Папка в которой должны находиться ваши данные. |
  | src/ | Это главная папка проекта. В ней хранятся все скрипты и коды. |
  | build.bat | Точка для запуска сборки проекта. Запускается в системе **Windows**. |
  | build.sh | Точка для запуска сборки проекта. Запускается в системе **MacOS** и **Linux**. |
  | run.bat | Точка для запуска скомпилированного проекта. Запускается в системе **Windows**. |
  | run.sh | Точка для запуска скомпилированного проекта. Запускается в системе **MacOS** и **Linux**. |
  | ... | _Вероятно могут быть и другие файлы, но основные из них выше_ |

#### 2. Папка сборки
Если с папками ```src/```, ```data/```, файлами сборки и запуска всё понятно, то что за папка **build/**?

Содержимое папки сборки:</br>
- build/</br>
  | File/Folder | Description |
  | --- | --- |
  | bin/ | Появится после запуска первой сборки. В ней хранятся все готовые бинарные файлы после сборки и динамические библиотеки для запуска программы. |
  | obj/ | Появится после запуска первой сборки. В ней хранятся объектные файлы исходников и прочее необходимое для компиляции. Она не удаляется для ускорения сборки. |
  | tools/ | Это важная папка системы сборки. В ней хранятся скрипты для сборки и запуска, и кэш сборки для её ускорения. Не трогайте эту папку и содержимое! |
  | config.json | Это конфигурационный файл системы сборки. В нём вы можете всё настроить под себя. |

#

### Система сборки

Относительно небольшая, но полная документация по системе сборки фреймворка.

#### 1. Конфигурация сборки
Это ```.json``` файл в котором прописаны параметры системы сборки.

Конфигурация выглядит примерно так:
```json
{
    "program-name":  "C Program Framework",
    "program-icon":  "data/icons/icon.ico",
    "source-dirs":   ["src/"],
    "build-dir":     "build/",
    "bin-dir-name":  "bin",
    "obj-dir-name":  "obj",
    "libs-output":   "",
    "build-logging": true,
    "multi-threads": true,
    "strip":         false,
    "progress-percent": true,
    "console-disabled": false,
    "defines":       [],
    "includes":      [],
    "libraries":     [],
    "libnames":      [],
    "optimization":  "-O2",
    "std-c":         "c17",
    "std-cpp":       "c++17",
    "compiler-s":    "gcc",
    "compiler-c":    "gcc",
    "compiler-cpp":  "g++",
    "linker":        "g++",
    "ld-file":       "",
    "warnings":      ["-Wall"],
    "compile-flags-s": [],
    "compile-flags-c": [],
    "compile-flags-cpp": [],
    "linker-flags":  [],
    "commands-after-build": []
}
```

Что за что отвечает:
| Key | Description |
| --- | --- |
| program-name | Название вашей программы в папке бинара. |
| program-icon | Иконка для программы. Работает только на системе **Windows**. Путь относителен от каталога проекта. |
| source-dirs | Массив относительных путей от каталога проекта до каталогов в которых надо искать исходники (**.c**/**.cpp** файлы). |
| build-dir | Название папки сборки. Вы можете переименовать папку ```build``` во что нибудь другое, и указать это название здесь, чтобы всё корректно работало. Также обновите это название в файлах ```build.bat/.sh``` и ```run.bat/.sh``` |
| bin-dir-name | Название папки в которую будут копироваться динамические библиотеки и размещаться главный бинарный файл программы. (Лучше не трогать). |
| obj-dir-name | Название папки в которой будут размещаться объектные файлы исходников и другие файлы для линковки. (Лучше не трогать). |
| libs-output  | Путь до папки в которую будут скопированы все динамические библиотеки. Путь относительно папки бинара сборки ```build/bin/```. Пример значения: ```"libs/"```, Результат: библиотеки копируются в ```build/bin/libs/``` |
| build-logging | Включить или выключить вывод подробной информации при сборке и запуске. |
| multi-threads | Использовать ли многопоточность процессора, во время анализа и компиляции файлов, для ускорения сборки. |
| strip | Сжать ли бинарный файл программы (убрав отладочную информацию и прочие поля в файле). |
| progress-percent | Отображать прогресс в процентах, или единицах. |
| console-disabled | Отключить консоль или нет. Работает только на системе **Windows**. |
| defines | Массив строк с определениями, которые добавляются на этапе компиляции файлов. Например: ```["MY_DEFINE=12345", "ENABLE_MODE", ...]``` и так далее. |
| includes | Массив относительных путей от каталога проекта до каталогов с заголовочными файлами, в которых надо искать заголовки. Например: ```["src/includes/", "src/app/core/", ...]``` и так далее. |
| libraries | Массив относительных путей от каталога проекта до каталогов библиотек. Например: ```["src/lib/", ...]``` и так далее. |
| libnames | Массив названий библиотек. Например: ```["SDL3", ...]``` и так далее. |
| optimization | Уровень оптимизации. Обычно от 0 до 3. Весь диапазон: ```-O0```, ```-O1```, ```-O2```, ```-O3```. Узнать какой уровень что делает можно в интернете. |
| std-c | Версия стандарта для языка **C**. |
| std-cpp | Версия стандарта для языка **C++**. |
| compiler-s | Компилятор для ассемблера. Можно указать либо просто команду доступную из терминала (например просто ```gcc```), либо путь до него (например ```/bin/gcc``` или  ```C:/Program Files/MinGW64/bin/gcc``` и тому подобное). |
| compiler-c | Компилятор для языка **C**. Можно указать либо просто команду доступную из терминала (например просто ```gcc```), либо путь до него (например ```/bin/gcc``` или  ```C:/Program Files/MinGW64/bin/gcc``` и тому подобное). |
| compiler-cpp | Компилятор для языка **C++**. Можно указать либо просто команду доступную из терминала (например просто ```g++```), либо путь до него (например ```/bin/g++``` или  ```C:/Program Files/MinGW64/bin/g++``` и тому подобное). |
| linker | Линкер для объединения объектных файлов в один исполняемый файл. Можно указать либо просто команду доступную из терминала (например просто ```g++```), либо путь до него (например ```/bin/g++``` или  ```C:/Program Files/MinGW64/bin/g++``` и тому подобное). |
| ld-file | Путь до скрипта линкера `.ld`. Путь должен быть относительно корня проекта. Например: `src/mycode/linker.ld`. Если оставить пустые кавычки, скрипт линкера не будет использоваться. |
| warnings | Массив строк флагов отвечающие за предупреждения во время компиляции. |
| compile-flags-s | Массив флагов компиляции ассемблера. |
| compile-flags-c | Массив флагов компиляции языка Си. |
| compile-flags-cpp | Массив флагов компиляции языка C++. |
| linker-flags | Массив дополнительных флагов линковки. |
| commands-after-build | Массив консольных команд, которые будут выполнены по очереди после усмешного выполнения системы сборки. Каждая строка - полноценная команда, которая будет выполнена. Порядок учитывается. |

**Особенности конфигурационного файла:**</br>
Такие параметры как: ```"program-icon"```, ```"console-disabled"```, работают только в системе **Windows**!

#### 2. Принцип работы
<img width="763" height="481" alt="" src="https://github.com/user-attachments/assets/d87cf796-dbfa-44c4-98ec-a17731c256ab" />

Система сборки написана на **Python**. При её запуске, происходит следующее:
1. Проверка переданных аргументов системе сборки. Например, флаг на очистку сборки, или например указание пути до файла конфигурации сборки.
2. Чтение файлов ```build/config.json``` и ```build/tools/metadata.json```
3. Переход из директории ```build/tools/``` в корневую директорию проекта.
4. Поиск всех файлов исходников (**.S**/**.c**/**.cpp**) по всем указанным каталогам.
5. Поиск всех динамических библиотек для копирования в каталог бинара.
6. Генерируем флаги сборки (флаги компиляции и линковки).
7. Получение нового **metadata**:
    - Анализ зависимостей исходников (получаем какие заголовочные файлы используются в исходнике, включая рекурсивное включение внутри заголовков).
    - Генерация новых метаданных на основе полученных данных о файлах и зависимостях (для сравнения с прошлым ```build/tools/metadata.json```).
8. Проверка каталогов сборки (такие как ```obj``` и ```bin```) и создание в случае отсутствия.
9. Проверка прошлого файла конфига в метаданных. Если конфиг прошлой сборки отличаются от текущего - Сброс сборки (рекомпиляция всех файлов).
10. Обработка файлов:
   - Получение данных из старой и новой метаданных.
   - Находим измененные, новые и удаленные файлы. А также включая изменения в используемых заголовочных файлах.
   - Удаляем все объектные файлы, если прошлая сборка была сделана на другой системе (сброс сборки).
   - Удаление объектных файлов по списку удалённых исходников.
   - Создание списка всех целевых **.o** файлов из актуальных **.c**/**.cpp** файлов.
   - Удаление **.o** файлов, исходников которых больше нет.
   - Проверка на отсутствующие **.o** файлы (если есть какой-то исходник у которого нет **.o** файла, добавляем в массив для компиляции).
11. Собираем программу:
    - Пересоздаём иконку программы для системы **Windows** при необходимости.
    - Компиляция исходников. Либо последовательно, либо параллельно на всех ядрах процессора (скрипт сам определяет кол-во логических ядер процессора). При компиляции исходника происходит:
      - Определение типа компилятора (например **compiler-c** или **compiler-cpp**) и стандарта для него (**std-c** или **std-cpp**).
      - Генерация финального массива флагов для компиляции.
      - Компиляция исходника.
    - Ожидание завершения компиляции других исходников.
    - Линкуем все объектные файлы в один исполняемый файл. При необходимости, используем скрипт линковщика.
12. Копируем необходимые библиотеки в папку бинара:
    - Проверяем путь до папки в которой должны быть библиотеки, и создаём недостающие папки (относительно папки бинара).
    - Копируем в созданный путь все необходимые библиотеки.
13. Сохраняем новые метаданные в случае удачной сборки.
14. Выполняем по очереди, массив команд терминала/консоли, которые мы указали в файле конфигурации. Полезно для автоматизации.

**Пометки:**
- В случае фатальной ошибки (при ошибках компиляции, линковки, или чего-либо ещё), ошибка выводится в терминал минуя отключение вывода информации и жёстко останавливает систему сборки через ```os._exit(1)``` чтобы прервать компиляцию других файлов и этапов сборки.
- Скрипт системы сборки хорошо документирован и разделён по этапам и функциям. Его можно изучить самому и более точно разобрать как он работает.

**Что делает (в двух словах):**
- Компилирует только изменённые, новые, и те исходники у которых нет объектного файла. А также рекомпилирует те файлы, чьи зависимости были отредактированы. Например: Заголовочный файл который используется в исходнике был отредактирован.
- Удаляет те объектные файлы, исходник которых удалён. Также удаляет лишние объекты, которых не должно быть (очистка от мусора). Она отслеживает платформу, конфиг сборки, версию системы сборки, файлы исходников и их время изменения. Делает рекомпиляцию (сброс сборки) в случае необходимости.
- Ищет в указанных папках библиотек, определенные библиотеки, чьи названия схожи с теми, что указаны в списке названий библиотек, и копирует их в папку ```build/bin/``` с возможностью указать путь в этой папке где должны находиться библиотеки.
- Распределяет компиляцию по ядрам процессора и ждёт завершение компиляции, чтобы начать линковку (использование многопоточности можно отключить в конфиг файле).
- Отслеживает результаты выполнения команд. В случае ошибки происходит жёсткая остановка сборки. Сохранение прогресса сборки при фатальной ошибке, не будет сохранено.
- Автоматически определяет какие компиляторы и стандарты для них использовать при компиляции определённых файлов, исходя из их расширения (для си файлов одно, для си++ другое).
- Выполняет массив консольных команд из конфиг файла, по очереди, после успешной сборки проекта. Полезно для автоматизации.

**Виды причин сброса сборки:**</br>
Все главные причины помечены префиксом ```[!]``` в логах сборки.</br>
В большинстве случаев причиной сброса является предостережение безопасности сборки. Причины:
- ```[!] Used clear flag for reset build.``` - В аргументы системы сборки был передан флаг очистки прошлой сборки.
- ```[!] File not found "metadata.json".``` - Файл метаданных в папке сборки отсутствовал во время сборки.
- ```[!] Build config edited.``` - Файл конфигурации сборки был отредактирован.
- ```[!] Build on a new system. Previous OS: <old_os>, Current OS: <new_os>``` - Проект собирается на другой системе, и необходимо пересобрать все исходники.

В любых случаях при сбросе сборки, в логах будет выведено: ```Recompiling all files (build reseted).```

#

### Аргументы запуска системы сборки
<img width="682" height="172" alt="image" src="https://github.com/user-attachments/assets/7d36837d-384e-4a18-aac7-edc398bb093c" />

Их совсем немного:
- ```-c``` или ```-clear``` - Удалить прошлую сборку и собрать всё заново (Сборка запускается).
- ```-v``` или ```-version``` - Получить версию системы сборки (Сборка не будет запущена).
- ```-cfg``` или ```-config``` - Указать путь до конфиг файла сборки (Сборка запускается).
- ```-h``` или ```-help``` - Получить помощь в аргументах запуска (Сборка не будет запущена).

Аргументы можно передавать прямо при вызове ```build.bat/.sh``` или напрямую при необходимости.</br>
Например: ```build.bat -version -help```</br>

> - Аргументы можно чередовать как угодно.
> - Сборка не будет запущена если присутствуют те аргументы, у которых помечено что **сборка не будет запущена**.
> - Очистка сборки сработает только если **сборка будет запущена**.

#

### Для запуска файлов ```build.sh``` и ```run.sh``` на **MacOS**
Откройте терминал по адресу папки проекта, где находятся эти файлы, и выполните следующее:</br>
```chmod +x build.sh run.sh```</br>
Это даст разрешение файлам выполняться.

#

### Связь со мной:
#### [Telegram](https://t.me/mr_lukov)
